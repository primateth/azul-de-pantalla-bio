function isRefLine(line){ return /^REF-\d{3}\./.test(line.trim()); }

const SECTION_SET = new Set([
  "MANUALES",
  "WIKI|PODCAST|BLOG",
  "WIKI|PODCAST|BLOGS",
  "DOCUMENTOS|ARTÍCULOS|ENTORNOS",
  "DOCUMENTOS|ARTICULOS|ENTORNOS",
  "DOCUMENTOS|ARTÍCULOS|ENTORNO",
  "DOCUMENTOS|ARTICULOS|ENTORNO",
  "HTMLS",
  "HTMLs"
]);

function normKey(s){
  return s.trim()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"") // quita tildes
    .toUpperCase();
}

function isSectionLine(line){
  const t = line.trim();
  if (!t) return false;
  if (t.startsWith("REF-")) return false;

  // Sección explícita por '|' o por lista blanca
  if (t.includes("|")) return true;

  const k = normKey(t);
  // Permitimos variantes con/sin tildes
  if (SECTION_SET.has(t.trim().toUpperCase()) || SECTION_SET.has(k.replace("Í","I").replace("Ó","O"))) return true;
  if (SECTION_SET.has(k)) return true;

  return false;
}

// helper: siguiente línea no vacía
function nextNonEmpty(lines, i){
  for (let j=i; j<lines.length; j++){
    const t = lines[j].trim();
    if (t) return t;
  }
  return "";
}

function looksUpperishAuthor(t){
  // Autores tipo BOECIO / EPIC GAMES / DEAGEL / IBN ASAD
  // Permitimos mayúsculas + espacios + puntos + guiones + & + apóstrofes
  const up = t === t.toUpperCase();
  const sane = /^[A-ZÁÉÍÓÚÜÑ0-9 .,'&\-;()]+$/.test(t);
  return up && sane && t.length <= 90;
}

function isAuthorLine(line, nextLine){
  const t = line.trim();
  if (!t) return false;
  if (t.startsWith("REF-")) return false;
  if (isSectionLine(t)) return false;

  // Caso clásico: APELLIDO, Nombre  o varios autores con ;
  if (t.includes(",") || t.includes(";")) return true;

  // Caso autor en mayúsculas sin coma (EPIC GAMES, BOECIO, DEAGEL...)
  // Solo si la siguiente línea es una REF, para no confundir con notas.
  if (looksUpperishAuthor(t) && isRefLine(nextLine)) return true;

  return false;
}

function parseBib(text){
  const rawLines = text.replace(/\r/g,"").split("\n");
  const lines = rawLines.map(l => l.trimEnd());

  const sections = [];
  let currentSection = { name:"BIBLIOGRAFÍA", authors:[] };
  sections.push(currentSection);

  let currentAuthor = null;
  let lastItem = null;

  for (let i=0; i<lines.length; i++){
    const line = (lines[i] || "").trim();
    if (!line) continue;

    // Ignora epígrafe repetido si está dentro del txt
    if (
      line.startsWith("Quizás es mejor") ||
      line.startsWith("Si el libro es malo") ||
      line.startsWith("Si el libro es bueno")
    ) continue;

    const nextLine = nextNonEmpty(lines, i+1);

    if (isSectionLine(line)){
      currentSection = { name: line, authors:[] };
      sections.push(currentSection);
      currentAuthor = null;
      lastItem = null;
      continue;
    }

    if (isAuthorLine(line, nextLine)){
      currentAuthor = { name: line, id: slug(line), items:[] };
      currentSection.authors.push(currentAuthor);
      lastItem = null;
      continue;
    }

    if (isRefLine(line)){
      if (!currentAuthor){
        // fallback: si NO hay autor, intenta usar la línea anterior no vacía como autor
        // (sirve si el txt tiene algún salto raro)
        const prev = nextNonEmpty(lines, Math.max(0, i-1));
        if (prev && !prev.startsWith("REF-") && !isSectionLine(prev)){
          currentAuthor = { name: prev, id: slug(prev), items:[] };
          currentSection.authors.push(currentAuthor);
        } else {
          currentAuthor = { name:"SIN AUTOR (REVISAR TXT)", id:"sin-autor", items:[] };
          currentSection.authors.push(currentAuthor);
        }
      }

      const m = line.match(/^(REF-\d{3})\.\s*(.*)$/);
      const item = {
        ref: m ? m[1] : "",
        raw: m ? m[2] : line,
        author: currentAuthor.name
      };
      // meta (título/año/editorial) si lo usas en tu render
      const meta = splitMeta(item.raw);
      item.title = meta.title;
      item.year = meta.year;
      item.publisher = meta.publisher;

      currentAuthor.items.push(item);
      lastItem = item;
      continue;
    }

    // Continuación de texto (líneas partidas tipo "vs. Heteroarcado.")
    if (lastItem){
      lastItem.raw = (lastItem.raw + " " + line).replace(/\s+/g," ").trim();
      const meta = splitMeta(lastItem.raw);
      lastItem.title = meta.title;
      lastItem.year = meta.year;
      lastItem.publisher = meta.publisher;
    }
  }

  return sections;
}
