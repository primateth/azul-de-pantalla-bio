<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bibliografía Azul de pantalla · Templo del dato</title>
  <meta name="description" content="Bibliografía Azul de pantalla. Templo del dato." />
  <meta name="theme-color" content="#0b0c22" />
  <style>
    :root{
      color-scheme: dark;
      --bg:#050616;
      --panel:rgba(18,20,56,.35);
      --panel2:rgba(10,12,34,.55);
      --border:rgba(110,130,255,.22);
      --text:#e9ecff;
      --muted:rgba(233,236,255,.72);
      --link:#6aa2ff;
      --btnbg:rgba(10,12,34,.70);
      --btnbd:rgba(110,130,255,.28);
    }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); line-height:1.55; }
    a{ color:var(--link); text-decoration:none; }
    a:hover{ text-decoration:underline; }
    .wrap{ max-width:1100px; margin:0 auto; padding:34px 18px 60px; }
    .top{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .badge{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 12px;
      border:1px solid var(--border);
      border-radius:999px;
      background:var(--panel2);
      letter-spacing:.6px;
      text-transform:uppercase;
      font-size:13px;
    }
    .dot{ width:8px; height:8px; border-radius:999px; background:#2b3cff; box-shadow:0 0 0 4px rgba(43,60,255,.15); }
    h1{ margin:14px 0 2px; font-size:40px; }
    h2{ margin:0 0 14px; font-size:18px; color:rgba(233,236,255,.78); font-weight:600; letter-spacing:.3px; }
    .sub{ margin:0 0 16px; color:var(--muted); max-width:95ch; }
    .card{ margin-top:14px; padding:16px; border:1px solid var(--border); border-radius:18px; background:var(--panel); }
    .toolbar{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    input[type="search"]{
      width:min(520px,100%);
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(110,130,255,.28);
      background:rgba(10,12,34,.55);
      color:var(--text);
      outline:none;
    }
    input[type="search"]::placeholder{ color:rgba(233,236,255,.5); }
    .toggles{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .toggle{
      display:inline-flex; gap:8px; align-items:center;
      padding:8px 10px;
      border:1px solid rgba(110,130,255,.22);
      border-radius:12px;
      background:rgba(10,12,34,.35);
      color:rgba(233,236,255,.86);
      font-size:13px;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .stats{ color:var(--muted); font-size:13px; }
    .toc{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .pill{
      padding:6px 10px;
      border:1px solid rgba(110,130,255,.22);
      border-radius:999px;
      background:rgba(10,12,34,.35);
      font-size:12px;
      color:rgba(233,236,255,.82);
    }
    details{ border:1px solid rgba(110,130,255,.18); border-radius:16px; background:rgba(10,12,34,.25); padding:10px 12px; margin:10px 0; }
    summary{ cursor:pointer; list-style:none; }
    summary::-webkit-details-marker{ display:none; }
    .sumline{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .author{ font-weight:700; letter-spacing:.2px; }
    .count{ color:var(--muted); font-size:13px; }
    ol{ margin:10px 0 0; padding-left:18px; }
    li{ margin:10px 0; }
    .row{ display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
    .left{ min-width:min(780px,100%); flex: 1 1 620px; }
    .ref{
      display:inline-block;
      min-width:108px;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      font-size:13px;
      color:rgba(233,236,255,.78);
    }
    .title{ color:rgba(233,236,255,.94); }
    .meta-year, .meta-pub{ color:rgba(233,236,255,.72); font-size:13px; margin-left:8px; }
    .meta-year{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; }
    .actions{ display:flex; gap:8px; align-items:center; flex:0 0 auto; }
    button.copy{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--btnbd);
      background:var(--btnbg);
      color:rgba(233,236,255,.92);
      cursor:pointer;
      font-size:13px;
      white-space:nowrap;
    }
    button.copy:hover{ filter: brightness(1.08); }
    button.copy:active{ transform: translateY(1px); }
    button.copy.ok{ border-color: rgba(150,255,200,.35); }
    button.copy.bad{ border-color: rgba(255,150,170,.35); }
    .mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; font-size:13px; color:rgba(233,236,255,.78); }
    .note{ color:var(--muted); font-size:13px; }
    .hide{ display:none !important; }
    body.clean .meta-year, body.clean .meta-pub{ display:none; }
  </style>
</head>

<body>
  <div class="wrap" id="top">
    <div class="top">
      <div class="badge"><span class="dot"></span><span>Azul de Pantalla · Bibliografía</span></div>
      <div class="mono">Fuente: <span class="mono">/bibliografia.txt</span></div>
    </div>

    <h1>Bibliografía Azul de pantalla</h1>
    <h2>Templo del dato</h2>

    <p class="sub">
      Quizás es mejor la bibliografía que el propio libro.<br>
      Si el libro es malo, la bibliografía siempre queda bien.<br>
      Si el libro es bueno, la bibliografía se atribuye el mérito.
    </p>

    <div class="card" id="bibliografia">
      <div class="toolbar">
        <input id="q" type="search" placeholder="Buscar por autor, título, editorial, año, REF-…" autocomplete="off" />
        <div class="toggles">
          <label class="toggle" title="Oculta años y editoriales">
            <input id="clean" type="checkbox" />
            <span>Modo limpio</span>
          </label>
        </div>
        <div class="stats" id="stats">Cargando…</div>
      </div>

      <div class="toc" id="toc"></div>
      <div id="out" style="margin-top:10px;"></div>

      <p class="note">
        QR: <span class="mono">https://primateth.github.io/azul-de-pantalla-bio/</span>
      </p>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    function slug(s){
      return (s || "")
        .trim()
        .toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
        .replace(/[^a-z0-9]+/g,"-")
        .replace(/^-+|-+$/g,"");
    }

    function escapeHtml(s){
      return (s || "").replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    // REF-001. | REF-017_2. | REF-302_1.
    function isRefLine(line){
      return /^REF-\d{3}(?:_\d+)?\./.test((line || "").trim());
    }

    function normKey(s){
      return (s || "").trim()
        .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
        .toUpperCase();
    }

    // Secciones “oficiales” de tu txt (futuro-proof)
    const SECTION_HEADS = new Set([
      "PODCASTS",
      "BLOGS",
      "TEXTOS RELIGIOSOS",
      "ANONIMOS",
      "ANÓNIMOS",
      "MANUALES"
    ].map(normKey));

    function isSectionHeader(line){
      const t = (line || "").trim();
      if (!t) return false;
      if (t.startsWith("REF-")) return false;
      return SECTION_HEADS.has(normKey(t));
    }

    function nextNonEmpty(lines, i){
      for (let j=i; j<lines.length; j++){
        const t = (lines[j] || "").trim();
        if (t) return t;
      }
      return "";
    }

    function looksUpperishAuthor(t){
      const s = (t || "").trim();
      const sane = /^[A-ZÁÉÍÓÚÜÑ0-9 .,'&\-;()]+$/.test(s);
      const upish = s === s.toUpperCase();
      const hasCommaOrSemi = s.includes(",") || s.includes(";");
      return (hasCommaOrSemi || (upish && sane)) && s.length <= 140;
    }

    function cleanAuthorName(name){
      let s = (name || "").trim().replace(/\s+/g, " ");
      s = s.replace(/\s*,\s*/g, ", ");
      s = s.replace(/,\s*$/,""); // "EPICURO," -> "EPICURO"
      // normaliza "IBN ,ASAD" -> "IBN ASAD" si es “todo mayúsculas corto”
      if (/^[A-ZÁÉÍÓÚÜÑ]{2,12}, [A-ZÁÉÍÓÚÜÑ]{2,12}$/.test(s)) s = s.replace(", ", " ");
      return s;
    }

    // Caso especial: "MANUALES, EPIC GAMES"
    function parseSectionAuthorLine(line){
      const t = (line || "").trim();
      const m = t.match(/^([^,]+),\s*(.+)$/);
      if (!m) return null;
      if (normKey(m[1]) !== "MANUALES") return null;
      return { section: "MANUALES", author: cleanAuthorName(m[2]) };
    }

    // Extrae título + (año) + editorial si encaja
    function splitMeta(text){
      const t = (text || "").trim();
      const re = /^(.*?)(\(\s*(?:\d{4}(?:\s*[–-]\s*\d{4})?|s\.\s*f\.)\s*\))\.\s*(.*)$/i;
      const m = t.match(re);
      if (!m) return { title: t, year: "", publisher: "" };
      return {
        title: (m[1] || "").trim().replace(/\s+/g," "),
        year: (m[2] || "").trim(),
        publisher: (m[3] || "").trim().replace(/\s+/g," ")
      };
    }

    function buildCopyText(it){
      const parts = [];
      if (it.author) parts.push(it.author);
      parts.push(`${it.ref}. ${it.title || it.raw}`.trim());
      const extras = [];
      if (it.year) extras.push(it.year);
      if (it.publisher) extras.push(it.publisher);
      if (extras.length) parts.push(extras.join(". "));
      return parts.join(" - ").replace(/\s+/g," ").trim();
    }

    function parseBib(text){
      const rawLines = (text || "").replace(/\r/g,"").split("\n");
      const lines = rawLines.map(l => (l || "").trimEnd());

      const sections = [];
      let currentSection = { name:"BIBLIOGRAFÍA", authors:[] };
      sections.push(currentSection);

      let currentAuthor = null;
      let lastItem = null;

      const HEADER_KEYS = new Set([
        "Bibliografía Azul de pantalla",
        "Templo del dato",
        "Quizás es mejor la bibliografía que el propio libro.",
        "Si el libro es malo, la bibliografía siempre queda bien.",
        "Si el libro es bueno, la bibliografía se atribuye el mérito."
      ].map(normKey));

      for (let i=0; i<lines.length; i++){
        const line = (lines[i] || "").trim();
        if (!line) continue;

        if (HEADER_KEYS.has(normKey(line))) continue;

        const nextLine = nextNonEmpty(lines, i+1);
        const isMain = normKey(currentSection.name) === normKey("BIBLIOGRAFÍA");

        // 1) Caso especial: "MANUALES, EPIC GAMES"
        const sa = parseSectionAuthorLine(line);
        if (sa){
          if (normKey(currentSection.name) !== normKey("MANUALES")){
            currentSection = { name:"MANUALES", authors:[] };
            sections.push(currentSection);
          }
          currentAuthor = { name: sa.author, id: slug(sa.author), items:[] };
          currentSection.authors.push(currentAuthor);
          lastItem = null;
          continue;
        }

        // 2) Sección explícita
        if (isSectionHeader(line)){
          currentSection = { name: line.trim(), authors:[] };
          sections.push(currentSection);
          currentAuthor = null;
          lastItem = null;
          continue;
        }

        // 3) Autor en 2 líneas (solo en BIBLIOGRAFÍA): INTERNATIONAL + FACT-CHECKING... + REF
        if (isMain){
          const a1 = cleanAuthorName(line);
          const a2raw = nextLine;
          const a2 = cleanAuthorName(a2raw);
          const next2 = nextNonEmpty(lines, i+2);

          const isTwoLineAuthor =
            looksUpperishAuthor(a1) &&
            a2raw && !isRefLine(a2raw) &&
            looksUpperishAuthor(a2) &&
            isRefLine(next2);

          if (isTwoLineAuthor){
            const combined = cleanAuthorName(a1 + " " + a2);
            currentAuthor = { name: combined, id: slug(combined), items:[] };
            currentSection.authors.push(currentAuthor);
            lastItem = null;
            i += 1; // consumimos la segunda línea
            continue;
          }
        }

        // 4) Autor normal
        if (!line.startsWith("REF-") && isRefLine(nextLine)){
          const candidate = cleanAuthorName(line);

          // En BIBLIOGRAFÍA: estricto (evita “Norma Editorial.” como autor)
          if (isMain){
            if (looksUpperishAuthor(candidate)){
              currentAuthor = { name: candidate, id: slug(candidate), items:[] };
              currentSection.authors.push(currentAuthor);
              lastItem = null;
              continue;
            }
          } else {
            // En secciones: flexible (PODCASTS admite “El submarino Subversivo”)
            currentAuthor = { name: candidate, id: slug(candidate), items:[] };
            currentSection.authors.push(currentAuthor);
            lastItem = null;
            continue;
          }
        }

        // 5) REF
        if (isRefLine(line)){
          if (!currentAuthor){
            // Si una sección trae refs directas sin autor, las colgamos de la propia sección
            const fallbackName = cleanAuthorName(currentSection.name);
            currentAuthor = { name: fallbackName, id: slug(fallbackName), items:[] };
            currentSection.authors.push(currentAuthor);
          }

          const m = line.match(/^(REF-\d{3}(?:_\d+)?)\.\s*(.*)$/);
          const ref = m ? m[1] : "";
          const raw = m ? m[2] : line;

          const meta = splitMeta(raw);
          const item = {
            ref,
            raw,
            title: meta.title,
            year: meta.year,
            publisher: meta.publisher,
            author: currentAuthor.name
          };
          item.copy = buildCopyText(item);

          currentAuthor.items.push(item);
          lastItem = item;
          continue;
        }

        // 6) Continuación de texto (líneas partidas)
        if (lastItem){
          lastItem.raw = (lastItem.raw + " " + line).replace(/\s+/g," ").trim();
          const meta = splitMeta(lastItem.raw);
          lastItem.title = meta.title;
          lastItem.year = meta.year;
          lastItem.publisher = meta.publisher;
          lastItem.copy = buildCopyText(lastItem);
        }
      }

      return sections.filter(s => s.authors.length > 0);
    }

    function hookCleanToggle(){
      const cb = $("clean");
      const key = "azul_biblio_clean";
      const saved = localStorage.getItem(key);
      if (saved === "1"){
        cb.checked = true;
        document.body.classList.add("clean");
      }
      cb.addEventListener("change", ()=>{
        document.body.classList.toggle("clean", cb.checked);
        localStorage.setItem(key, cb.checked ? "1" : "0");
      });
    }

    function hookSearch(){
      const q = $("q");
      const details = Array.from(document.querySelectorAll("details"));

      q.addEventListener("input", () => {
        const term = q.value.trim().toLowerCase();
        let shown = 0;

        for (const det of details){
          const items = Array.from(det.querySelectorAll("li"));
          let any = false;

          for (const li of items){
            const ok = !term || li.dataset.search.includes(term);
            li.classList.toggle("hide", !ok);
            if (ok) { any = true; shown++; }
          }

          det.classList.toggle("hide", !any);
          det.open = term ? any : false;
        }

        if (term) $("stats").textContent = `${shown} coincidencias · filtro activo`;
        else {
          const total = document.querySelectorAll("li").length;
          const authors = document.querySelectorAll("details").length;
          $("stats").textContent = `${total} referencias · ${authors} autores/bloques`;
        }
      });
    }

    async function copyText(text){
      try{
        await navigator.clipboard.writeText(text);
        return true;
      }catch(e){
        try{
          const ta = document.createElement("textarea");
          ta.value = text;
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          document.body.removeChild(ta);
          return true;
        }catch(_){
          return false;
        }
      }
    }

    function hookCopyButtons(){
      document.querySelectorAll("button.copy").forEach(btn=>{
        btn.addEventListener("click", async () => {
          const original = btn.textContent;
          const ok = await copyText(btn.dataset.copy || "");
          btn.classList.remove("ok","bad");
          btn.classList.add(ok ? "ok" : "bad");
          btn.textContent = ok ? "Copiado" : "Error";
          setTimeout(()=>{
            btn.classList.remove("ok","bad");
            btn.textContent = original;
          }, 900);
        });
      });
    }

    function jumpToHash(){
      const h = (location.hash || "").trim();
      if (!h) return;
      const el = document.querySelector(h);
      if (!el) return;
      const det = el.closest("details");
      if (det) det.open = true;
      el.scrollIntoView({ behavior:"smooth", block:"start" });
    }

    function render(sections){
      const out = $("out");
      const toc = $("toc");
      out.innerHTML = "";
      toc.innerHTML = "";

      let totalItems = 0;
      let totalAuthors = 0;

      for (const sec of sections){
        const secId = slug(sec.name);
        const a = document.createElement("a");
        a.className = "pill";
        a.href = "#" + secId;
        a.textContent = sec.name;
        toc.appendChild(a);
      }

      for (const sec of sections){
        const secId = slug(sec.name);
        const secEl = document.createElement("section");
        secEl.id = secId;
        secEl.style.marginTop = "18px";

        const h = document.createElement("div");
        h.className = "mono";
        h.style.margin = "10px 0 6px";
        h.innerHTML = "<b>" + escapeHtml(sec.name) + "</b>";
        secEl.appendChild(h);

        for (const au of sec.authors){
          totalAuthors++;
          totalItems += au.items.length;

          const det = document.createElement("details");
          det.open = false;

          const sum = document.createElement("summary");
          const sumline = document.createElement("div");
          sumline.className = "sumline";
          sumline.innerHTML = `
            <span class="author" id="${au.id}">${escapeHtml(au.name)}</span>
            <span class="count">${au.items.length} refs</span>
          `;
          sum.appendChild(sumline);
          det.appendChild(sum);

          const ol = document.createElement("ol");
          for (const it of au.items){
            const li = document.createElement("li");
            li.dataset.search = (it.author + " " + it.ref + " " + it.raw + " " + it.year + " " + it.publisher).toLowerCase();

            const row = document.createElement("div");
            row.className = "row";

            const left = document.createElement("div");
            left.className = "left";
            left.innerHTML =
              `<span class="ref">${escapeHtml(it.ref)}</span>` +
              `<span class="title">${escapeHtml(it.title || it.raw)}</span>` +
              (it.year ? `<span class="meta-year">${escapeHtml(it.year)}</span>` : ``) +
              (it.publisher ? `<span class="meta-pub">${escapeHtml(it.publisher)}</span>` : ``);

            const actions = document.createElement("div");
            actions.className = "actions";

            const btn = document.createElement("button");
            btn.className = "copy";
            btn.type = "button";
            btn.textContent = "Copiar cita";
            btn.dataset.copy = it.copy;

            actions.appendChild(btn);
            row.appendChild(left);
            row.appendChild(actions);

            li.appendChild(row);
            ol.appendChild(li);
          }

          det.appendChild(ol);
          secEl.appendChild(det);
        }

        out.appendChild(secEl);
      }

      $("stats").textContent = `${totalItems} referencias · ${totalAuthors} autores/bloques`;

      hookSearch();
      hookCopyButtons();
      jumpToHash();
      window.addEventListener("hashchange", jumpToHash);
    }

    async function main(){
      hookCleanToggle();

      const url = "bibliografia.txt?v=" + Date.now();
      const res = await fetch(url);
      if (!res.ok){
        $("stats").textContent = "No puedo leer bibliografia.txt (¿está en la raíz del repo?)";
        return;
      }
      const text = await res.text();
      const sections = parseBib(text);
      render(sections);
    }

    main();
  </script>
</body>
</html>

