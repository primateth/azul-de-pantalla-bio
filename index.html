<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bibliografía Azul de Pantalla · Templo del dato</title>
  <meta name="description" content="Bibliografía pública del proyecto Azul de Pantalla: Templo del dato. QR-friendly." />
  <style>
    :root{
      --bg:#07091a;
      --bg2:#0b0e28;
      --ink: rgba(233,236,255,.92);
      --muted: rgba(233,236,255,.68);
      --muted2: rgba(233,236,255,.52);
      --line: rgba(110,130,255,.16);
      --line2: rgba(110,130,255,.22);
      --chip: rgba(10,12,34,.35);
      --chip2: rgba(10,12,34,.7);
      --accent: rgba(110,130,255,.55);
    }
    *{ box-sizing: border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--ink);
      background:
        radial-gradient(1200px 900px at 10% 10%, rgba(110,130,255,.18), transparent 60%),
        radial-gradient(1200px 900px at 90% 20%, rgba(80,220,160,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(255,200,80,.08), transparent 60%),
        linear-gradient(180deg, var(--bg), var(--bg2));
    }
    .wrap{ max-width: 1160px; margin: 0 auto; padding: 22px 16px 60px; }
    .card{
      background: rgba(7,9,26,.55);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,.25);
      overflow: hidden;
      backdrop-filter: blur(10px);
    }
    header.hero{
      padding: 18px 18px 14px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(10,12,34,.70), rgba(10,12,34,.25));
    }
    .top{
      display:flex;
      gap:12px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: space-between;
    }
    .badge{
      display:flex;
      align-items:center;
      gap:10px;
      font-size: 13px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid var(--line2);
      background: rgba(10,12,34,.55);
      color: var(--muted);
    }
    .dot{
      width:10px; height:10px; border-radius: 50%;
      background: rgba(110,130,255,.65);
      box-shadow: 0 0 0 3px rgba(110,130,255,.16);
    }
    .nav{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .nav a{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(110,130,255,.22);
      background: rgba(10,12,34,.35);
      color: rgba(233,236,255,.86);
      font-size: 13px;
      text-decoration:none;
      white-space: nowrap;
    }
    .nav a:hover{ filter: brightness(1.08); }
    .nav a:active{ transform: translateY(1px); }
    .nav a.primary{
      border-color: rgba(110,130,255,.35);
      background: rgba(10,12,34,.70);
    }
    h1{ margin: 14px 0 0; font-size: 22px; letter-spacing: .2px; }
    .sub{
      margin: 6px 0 0;
      font-size: 13.5px;
      color: var(--muted);
      line-height: 1.55;
    }
    .epigraph{
      margin-top: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px dashed rgba(110,130,255,.22);
      color: rgba(233,236,255,.75);
      background: rgba(10,12,34,.28);
      font-size: 13px;
      line-height: 1.55;
    }
    .grid{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 14px;
      padding: 14px;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }
    aside{
      border: 1px solid var(--line);
      border-radius: 16px;
      background: rgba(10,12,34,.22);
      padding: 12px;
    }
    .search{
      display:flex;
      gap: 8px;
      align-items:center;
      margin-bottom: 10px;
    }
    .search input{
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(10,12,34,.45);
      color: var(--ink);
      outline: none;
      font-size: 14px;
    }
    .search button{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(10,12,34,.45);
      color: var(--muted);
      cursor: pointer;
    }
    .search button:hover{ filter: brightness(1.08); }
    .tocTitle{
      margin: 10px 0 6px;
      font-size: 12px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted2);
    }
    .toc a{
      display:block;
      padding: 8px 10px;
      border-radius: 12px;
      text-decoration:none;
      border: 1px solid transparent;
      color: rgba(233,236,255,.86);
      font-size: 13px;
      line-height: 1.25;
    }
    .toc a small{
      display:block;
      margin-top: 2px;
      color: rgba(233,236,255,.55);
      font-size: 11.5px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
    .toc a:hover{
      background: rgba(110,130,255,.10);
      border-color: rgba(110,130,255,.18);
    }
    .metaLine{
      margin-top: 10px;
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
      color: var(--muted2);
      font-size: 12px;
    }
    .pill{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(110,130,255,.18);
      background: rgba(10,12,34,.35);
    }
    main{
      border: 1px solid var(--line);
      border-radius: 16px;
      background: rgba(10,12,34,.18);
      padding: 14px;
      min-height: 420px;
    }
    .status{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .status .hint{ color: var(--muted2); font-size: 12.5px; }
    .status .ok{ color: rgba(80,220,160,.85); font-size: 12.5px; }
    .status .bad{ color: rgba(255,120,120,.85); font-size: 12.5px; }
    section.sec{
      margin-top: 18px;
      padding-top: 10px;
      border-top: 1px solid rgba(110,130,255,.14);
    }
    section.sec:first-of-type{ margin-top: 0; padding-top: 0; border-top: none; }
    h2{ margin: 0 0 8px; font-size: 16px; letter-spacing: .2px; }
    details.author{
      border: 1px solid rgba(110,130,255,.16);
      background: rgba(10,12,34,.26);
      border-radius: 14px;
      margin: 10px 0;
      overflow: hidden;
    }
    details.author summary{
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    details.author summary::-webkit-details-marker{ display:none; }
    .authorName{ font-weight: 600; font-size: 13.8px; color: rgba(233,236,255,.90); }
    .authorCount{
      font-size: 12px;
      color: rgba(233,236,255,.62);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(110,130,255,.16);
      background: rgba(7,9,26,.35);
      white-space: nowrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
    .items{ padding: 6px 12px 10px; border-top: 1px solid rgba(110,130,255,.12); }
    .item{
      display:flex;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px dashed rgba(110,130,255,.12);
      align-items:flex-start;
    }
    .item:last-child{ border-bottom: none; }
    .ref{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      color: rgba(110,130,255,.92);
      min-width: 112px;
      padding-top: 1px;
    }
    .txt{
      font-size: 13.4px;
      line-height: 1.55;
      color: rgba(233,236,255,.86);
      word-break: break-word;
    }
    .empty{
      padding: 18px 14px;
      border-radius: 14px;
      border: 1px dashed rgba(110,130,255,.22);
      color: var(--muted);
      background: rgba(10,12,34,.20);
      font-size: 13px;
      line-height: 1.6;
    }
    footer{
      margin-top: 14px;
      color: rgba(233,236,255,.45);
      font-size: 12px;
      text-align: center;
    }
    footer a{ color: rgba(233,236,255,.60); }
  </style>
</head>

<body>
  <a id="top"></a>
  <div class="wrap">
    <div class="card">
      <header class="hero">
        <div class="top">
          <div class="badge" title="GitHub Pages">
            <span class="dot"></span>
            <span>Azul de Pantalla · Bibliografía</span>
          </div>

          <nav class="nav" aria-label="Menú">
            <a class="primary" href="#top" title="Enlace de compra aún no publicado">Comprar (próximamente)</a>
            <a href="mailto:mercurius81@proton.me?subject=Azul%20de%20Pantalla%20-%20Contacto">Contacto</a>
            <a href="#bibliografia">Bibliografía</a>
            <a href="https://github.com/primateth/azul-de-pantalla-bio" target="_blank" rel="noopener">Repo</a>
            <a href="bibliografia.txt" target="_blank" rel="noopener">Descargar</a>
          </nav>
        </div>

        <h1>Bibliografía Azul de Pantalla</h1>
        <p class="sub">Templo del dato. Lista pública de referencias (y coartada elegante para cualquier libro).</p>

        <div class="epigraph" id="bibliografia">
          <div>Quizás es mejor la bibliografía que el propio libro.</div>
          <div>Si el libro es malo, la bibliografía siempre queda bien.</div>
          <div>Si el libro es bueno, la bibliografía se atribuye el mérito.</div>
        </div>
      </header>

      <div class="grid">
        <aside>
          <div class="search">
            <input id="q" type="search" placeholder="Buscar por autor, REF o título…" autocomplete="off" />
            <button id="clear" type="button" title="Limpiar">✕</button>
          </div>

          <div class="tocTitle">Autores (BIBLIOGRAFÍA)</div>
          <div id="tocAuthors" class="toc"></div>

          <div class="tocTitle" style="margin-top:14px">Secciones</div>
          <div id="tocSections" class="toc"></div>

          <div class="metaLine">
            <span class="pill" id="countAuthors">Autores: …</span>
            <span class="pill" id="countRefs">Refs: …</span>
          </div>
        </aside>

        <main>
          <div class="status">
            <div class="hint">Fuente: <span class="pill">bibliografia.txt</span> (raíz del repo)</div>
            <div id="loadState" class="ok">Cargando…</div>
          </div>

          <div id="content"></div>

          <footer>
            QR-friendly · <a href="#top">Subir</a>
          </footer>
        </main>
      </div>
    </div>
  </div>

  <script>
    // ===== Helpers =====
    function normKey(s){
      return (s || "").trim()
        .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
        .toUpperCase();
    }
    function slug(s){
      const t = (s || "").trim()
        .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g,"-")
        .replace(/^-+|-+$/g,"");
      return t || "x";
    }
    function escapeHtml(s){
      return String(s || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
    function nextNonEmpty(lines, i){
      for (let j=i; j<lines.length; j++){
        const t = (lines[j] || "").trim();
        if (t) return t;
      }
      return "";
    }
    function isRefLine(line){
      return /^REF-\d{3}(?:_\d+)?\./.test((line || "").trim());
    }

    const MAIN_SECTION = "BIBLIOGRAFÍA";
    const SECTION_ORDER = ["BIBLIOGRAFÍA","PODCASTS","BLOGS","MANUALES","TEXTOS RELIGIOSOS"].map(normKey);

    const HEADER_PREFIXES = [
      "BIBLIOGRAFIA AZUL",
      "TEMPLO DEL DATO",
      "QUIZAS ES MEJOR LA BIBLIOGRAFIA",
      "SI EL LIBRO ES MALO",
      "SI EL LIBRO ES BUENO"
    ];

    function isHeaderLine(t){
      const k = normKey(t);
      return HEADER_PREFIXES.some(p => k.startsWith(p));
    }

    function isSectionTitle(t){
      const k = normKey(t);
      return SECTION_ORDER.includes(k);
    }

    // Compatibilidad: "MANUALES, EPIC GAMES" = sección MANUALES, autor EPIC GAMES
    function parseSectionAuthorLine(line){
      const t = (line || "").trim();
      if (!t.includes(",")) return null;
      const parts = t.split(",").map(p=>p.trim()).filter(Boolean);
      if (parts.length < 2) return null;

      const section = parts[0];
      const author = parts.slice(1).join(", ").trim();
      if (SECTION_ORDER.includes(normKey(section))) return { section, author };
      return null;
    }

    // Ref sort key: REF-017_2 => [17,2]
    function refKey(ref){
      const m = String(ref || "").match(/^REF-(\d{3})(?:_(\d+))?$/);
      if (!m) return [999999, 999999];
      const a = parseInt(m[1],10);
      const b = m[2] ? parseInt(m[2],10) : 0;
      return [a,b];
    }

    function refRange(items){
      if (!items || !items.length) return { first:"", last:"", count:0 };
      const refs = items.map(it => it.ref).filter(Boolean);
      if (!refs.length) return { first:"", last:"", count: items.length };
      refs.sort((x,y)=>{
        const [ax,bx]=refKey(x), [ay,by]=refKey(y);
        return ax!==ay ? ax-ay : bx-by;
      });
      return { first: refs[0], last: refs[refs.length-1], count: items.length };
    }

    function authorSortKey(name){
      return normKey(name);
    }

    function splitMeta(raw){
      const s = (raw || "").trim();
      const m = s.match(/^(.*?)(\(\d{4}\))?(?:\.\s*)?(.*)?$/);
      const title = (m && m[1]) ? m[1].trim() : s;
      const year = (m && m[2]) ? m[2].replace(/[()]/g,"") : "";
      const tail = (m && m[3]) ? m[3].trim() : "";
      const publisher = tail || "";
      return { title, year, publisher };
    }

    function isAuthorLine(line, nextLine, currentSectionName){
      const t = (line || "").trim();
      if (!t) return false;
      if (t.startsWith("REF-")) return false;
      if (isHeaderLine(t)) return false;
      if (isSectionTitle(t)) return false;
      if (parseSectionAuthorLine(t)) return false;

      const nextIsRef = isRefLine(nextLine);

      // En BIBLIOGRAFÍA: estricto (coma/; o MAYÚSCULAS + REF)
      if (normKey(currentSectionName) === normKey(MAIN_SECTION)){
        if (t.includes(",") || t.includes(";")) return true;
        if (t === t.toUpperCase() && nextIsRef) return true;
        return false;
      }

      // En otras secciones: si la siguiente es REF, aceptamos como autor aunque sea Title Case (Ej: "El submarino Subversivo")
      if (nextIsRef && t.length <= 90 && !t.endsWith(".")) return true;

      // fallback clásico
      if (t.includes(",") || t.includes(";")) return true;
      if (t === t.toUpperCase() && nextIsRef) return true;

      return false;
    }

    function parseBib(text){
      const rawLines = text.replace(/\r/g,"").split("\n");
      const lines = rawLines.map(l => (l || "").trimEnd());

      const sections = [];
      let currentSection = { name: MAIN_SECTION, id: slug(MAIN_SECTION), authors:[] };
      sections.push(currentSection);

      let currentAuthor = null;
      let lastItem = null;

      for (let i=0; i<lines.length; i++){
        const line = (lines[i] || "").trim();
        if (!line) continue;

        if (isHeaderLine(line)) continue;

        // "MANUALES, EPIC GAMES"
        const legacy = parseSectionAuthorLine(line);
        if (legacy){
          currentSection = { name: legacy.section, id: slug(legacy.section), authors:[] };
          sections.push(currentSection);

          currentAuthor = { name: legacy.author, id: `${currentSection.id}--${slug(legacy.author)}`, items:[] };
          currentSection.authors.push(currentAuthor);
          lastItem = null;
          continue;
        }

        // Sección explícita
        if (isSectionTitle(line)){
          currentSection = { name: line, id: slug(line), authors:[] };
          sections.push(currentSection);
          currentAuthor = null;
          lastItem = null;
          continue;
        }

        const nextLine = nextNonEmpty(lines, i+1);

        // Autor multilinea (INTERNATIONAL / FACT-CHECKING NETWORK...)
        const n1 = nextNonEmpty(lines, i+1);
        const idxN1 = lines.findIndex((_, idx) => idx > i && (lines[idx] || "").trim() === n1);
        const n2 = nextNonEmpty(lines, (idxN1 >= 0 ? idxN1+1 : i+2));
        if (line === line.toUpperCase() && n1 && n1 === n1.toUpperCase() && isRefLine(n2)){
          const combined = (line + " " + n1).replace(/\s+/g," ").trim();
          currentAuthor = { name: combined, id: `${currentSection.id}--${slug(combined)}`, items:[] };
          currentSection.authors.push(currentAuthor);
          lastItem = null;
          i = (idxN1 >= 0 ? idxN1 : i+1);
          continue;
        }

        // Autor
        if (isAuthorLine(line, nextLine, currentSection.name)){
          currentAuthor = { name: line, id: `${currentSection.id}--${slug(line)}`, items:[] };
          currentSection.authors.push(currentAuthor);
          lastItem = null;
          continue;
        }

        // REF
        if (isRefLine(line)){
          if (!currentAuthor){
            // En secciones no principales, es más limpio agrupar en VARIOS
            const fallbackName = (normKey(currentSection.name) === normKey(MAIN_SECTION))
              ? "SIN AUTOR (REVISAR TXT)"
              : "VARIOS";
            currentAuthor = { name: fallbackName, id: `${currentSection.id}--${slug(fallbackName)}`, items:[] };
            currentSection.authors.push(currentAuthor);
          }
          const m = line.match(/^(REF-\d{3}(?:_\d+)?)\.\s*(.*)$/);
          const ref = m ? m[1] : "";
          const raw = m ? m[2] : line.replace(/^REF-\d{3}(?:_\d+)?\.\s*/,"");
          const meta = splitMeta(raw);

          const item = { ref, raw, title: meta.title, year: meta.year, publisher: meta.publisher };
          currentAuthor.items.push(item);
          lastItem = item;
          continue;
        }

        // Continuación (líneas partidas)
        if (lastItem){
          lastItem.raw = (lastItem.raw + " " + line).replace(/\s+/g," ").trim();
          const meta = splitMeta(lastItem.raw);
          lastItem.title = meta.title;
          lastItem.year = meta.year;
          lastItem.publisher = meta.publisher;
        }
      }

      return sections;
    }

    function sortAll(sections){
      // Orden secciones fijo: BIBLIOGRAFÍA primero, el resto después
      const pos = new Map(SECTION_ORDER.map((k,i)=>[k,i]));
      sections.sort((a,b)=>{
        const pa = pos.has(normKey(a.name)) ? pos.get(normKey(a.name)) : 999;
        const pb = pos.has(normKey(b.name)) ? pos.get(normKey(b.name)) : 999;
        if (pa !== pb) return pa - pb;
        return (a.name||"").localeCompare((b.name||""), "es", { sensitivity:"base" });
      });

      // Orden autores e items
      for (const s of sections){
        for (const a of s.authors){
          a.items.sort((x,y)=>{
            const [ax,bx]=refKey(x.ref), [ay,by]=refKey(y.ref);
            if (ax!==ay) return ax-ay;
            if (bx!==by) return bx-by;
            return (x.raw||"").localeCompare((y.raw||""), "es", { sensitivity:"base" });
          });
        }
        s.authors.sort((x,y)=> authorSortKey(x.name).localeCompare(authorSortKey(y.name), "es", { sensitivity:"base" }));
      }

      return sections;
    }

    function countAll(sections){
      let authors = 0, refs = 0;
      for (const s of sections){
        authors += s.authors.length;
        for (const a of s.authors) refs += a.items.length;
      }
      return { authors, refs };
    }

    // ===== Render =====
    function renderSidebarAuthors(mainSection){
      const el = document.getElementById("tocAuthors");
      el.innerHTML = "";

      if (!mainSection || !mainSection.authors.length){
        el.innerHTML = `<div class="empty">Sin autores en BIBLIOGRAFÍA (o filtro sin resultados).</div>`;
        return;
      }

      for (const a of mainSection.authors){
        const rr = refRange(a.items);
        const refText = rr.first ? (rr.first === rr.last ? rr.first : `${rr.first}–${rr.last}`) : "";
        const link = document.createElement("a");
        link.href = "#" + a.id;
        link.innerHTML = `${escapeHtml(a.name)}${refText ? `<small>${escapeHtml(refText)}</small>` : ""}`;
        el.appendChild(link);
      }
    }

    function renderSidebarSections(sections){
      const el = document.getElementById("tocSections");
      el.innerHTML = "";

      for (const s of sections){
        const a = document.createElement("a");
        a.href = "#" + s.id;
        a.textContent = s.name;
        el.appendChild(a);
      }
    }

    function authorSummaryChip(author){
      const rr = refRange(author.items);
      const refText = rr.first ? (rr.first === rr.last ? rr.first : `${rr.first}–${rr.last}`) : "";
      const count = rr.count || 0;
      return refText ? `${refText} · ${count}` : `${count} refs`;
    }

    function renderContent(sections){
      const root = document.getElementById("content");
      root.innerHTML = "";

      for (const s of sections){
        const sec = document.createElement("section");
        sec.className = "sec";
        sec.id = s.id;

        const h2 = document.createElement("h2");
        h2.textContent = s.name;
        sec.appendChild(h2);

        if (!s.authors.length){
          const empty = document.createElement("div");
          empty.className = "empty";
          empty.textContent = "Sección vacía. Si no es intencional, revisa el TXT.";
          sec.appendChild(empty);
          root.appendChild(sec);
          continue;
        }

        for (const a of s.authors){
          const det = document.createElement("details");
          det.className = "author";
          det.id = a.id;

          const sum = document.createElement("summary");

          const left = document.createElement("div");
          left.className = "authorName";
          left.textContent = a.name;

          const right = document.createElement("div");
          right.className = "authorCount";
          right.textContent = authorSummaryChip(a);

          sum.appendChild(left);
          sum.appendChild(right);
          det.appendChild(sum);

          const items = document.createElement("div");
          items.className = "items";

          for (const it of a.items){
            const row = document.createElement("div");
            row.className = "item";
            row.id = `${a.id}--${slug(it.ref || it.title || "x")}`;

            const ref = document.createElement("div");
            ref.className = "ref";
            ref.textContent = it.ref || "REF";

            const txt = document.createElement("div");
            txt.className = "txt";
            txt.innerHTML = escapeHtml(it.raw || "");

            row.appendChild(ref);
            row.appendChild(txt);
            items.appendChild(row);
          }

          det.appendChild(items);
          sec.appendChild(det);
        }

        root.appendChild(sec);
      }
    }

    function openFromHash(){
      const h = (location.hash || "").replace("#","").trim();
      if (!h) return;

      const el = document.getElementById(h);
      if (!el) return;

      if (el.tagName === "DETAILS"){
        el.open = true;
        el.scrollIntoView({behavior:"smooth", block:"start"});
        return;
      }
      el.scrollIntoView({behavior:"smooth", block:"start"});

      // si hash apunta a una fila item (div.item), abre su details padre
      if (el.classList && el.classList.contains("item")){
        const parentDetails = el.closest("details.author");
        if (parentDetails) parentDetails.open = true;
      }
    }

    function applyFilter(sections, query){
      const q = normKey(query || "");
      if (!q) return sections;

      const out = [];
      for (const s of sections){
        const ns = { ...s, authors: [] };
        for (const a of s.authors){
          const authorHit = normKey(a.name).includes(q);
          const items = a.items.filter(it => {
            return authorHit ||
              normKey(it.ref).includes(q) ||
              normKey(it.raw).includes(q) ||
              normKey(it.title).includes(q);
          });
          if (items.length){
            ns.authors.push({ ...a, items });
          }
        }
        if (ns.authors.length) out.push(ns);
      }
      return out;
    }

    // ===== Boot =====
    (async function(){
      const loadState = document.getElementById("loadState");
      try{
        const res = await fetch("bibliografia.txt", { cache: "no-store" });
        if (!res.ok) throw new Error("No se pudo cargar bibliografia.txt (" + res.status + ")");

        const text = await res.text();
        let sections = parseBib(text);
        sections = sortAll(sections);

        const counts = countAll(sections);
        document.getElementById("countAuthors").textContent = "Autores: " + counts.authors;
        document.getElementById("countRefs").textContent = "Refs: " + counts.refs;

        const main = sections.find(s => normKey(s.name) === normKey(MAIN_SECTION));
        renderSidebarAuthors(main);
        renderSidebarSections(sections);

        renderContent(sections);

        loadState.className = "ok";
        loadState.textContent = "Listo";

        setTimeout(openFromHash, 50);
        window.addEventListener("hashchange", () => setTimeout(openFromHash, 30));

        const input = document.getElementById("q");
        const clear = document.getElementById("clear");

        function rerender(){
          const filtered = applyFilter(sections, input.value);
          const mainF = filtered.find(s => normKey(s.name) === normKey(MAIN_SECTION));
          renderSidebarAuthors(mainF);
          renderSidebarSections(filtered);
          renderContent(filtered);

          if ((input.value || "").trim()){
            document.querySelectorAll("details.author").forEach(d => d.open = true);
          }
        }

        input.addEventListener("input", rerender);
        clear.addEventListener("click", () => { input.value=""; rerender(); input.focus(); });

      }catch(err){
        loadState.className = "bad";
        loadState.textContent = "Error";
        document.getElementById("content").innerHTML = `
          <div class="empty">
            <div style="margin-bottom:8px"><b>No pude cargar bibliografia.txt</b></div>
            <ul style="margin:0; padding-left:18px; color: rgba(233,236,255,.72)">
              <li>Debe estar en la raíz del repo, junto a <b>index.html</b>.</li>
              <li>Nombre exacto: <b>bibliografia.txt</b>.</li>
              <li>Tras el push, espera el despliegue de Pages (a veces tarda un poco).</li>
            </ul>
            <div style="margin-top:10px; color: rgba(233,236,255,.62)">${escapeHtml(err.message || String(err))}</div>
          </div>
        `;
      }
    })();
  </script>
</body>
</html>
